<!DOCTYPE html>
<html lang="en" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: black;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@v0.176.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.176.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <title>corytheboyd.com</title>
  </head>
  <body class="h-screen w-screen">
    <div class="h-full flex items-center flex-col">
      <div
        class="flex flex-col items-center w-full h-full max-w-5xl"
      >
        <div>
          <h1 class="text-white text-8xl font-bold font-mono">INTERNET</h1>
        </div>
        <earth-globe class="w-xl"></earth-globe>
      </div>
    </main>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      class EarthGlobe extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          const style = document.createElement("style");
          style.textContent = `:host { display: block; aspect-ratio: 1/1; height: 100%; width: auto; max-width: 100vw; margin: auto; }`;
          this.shadowRoot.appendChild(style);
          this.container = document.createElement("div");
          this.container.style.width = "100%";
          this.container.style.height = "100%";
          this.container.style.position = "relative";
          this.shadowRoot.appendChild(this.container);
        }
        connectedCallback() {
          this.initThree();
          window.addEventListener("resize", this.handleResize);
        }
        disconnectedCallback() {
          window.removeEventListener("resize", this.handleResize);
          if (this._animationFrameId) cancelAnimationFrame(this._animationFrameId);
        }
        getSquareSize = () => {
          // Use the actual rendered size of the element
          return Math.min(this.offsetWidth, this.offsetHeight);
        };
        handleResize = () => {
          const size = this.getSquareSize();
          if (this.renderer) this.renderer.setSize(128, 128, false);
          if (this.camera) {
            this.camera.aspect = 1;
            this.camera.updateProjectionMatrix();
          }
          if (this.fitCameraToEarth) this.fitCameraToEarth();
        };
        initThree() {
          const EARTH_ROTATION_SPEED = 0.3;
          let previousTime = 0;
          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(48.5, 1, 0.1, 2000);
          // Lighting
          const light = new THREE.DirectionalLight(0xffffff, 5.5);
          light.position.set(0, 0, 100);
          light.target.position.set(0, 0, 0);
          this.scene.add(light);
          this.scene.add(light.target);
          this.renderer = new THREE.WebGLRenderer({
            antialias: false,
            alpha: true,
          });
          this.container.innerHTML = "";
          this.container.appendChild(this.renderer.domElement);
          // Style the canvas for pixelation
          this.renderer.domElement.style.width = '100%';
          this.renderer.domElement.style.imageRendering = 'pixelated';
          // Load model
          const loader = new GLTFLoader();
          loader.load("earth_low_poly.glb", (gltf) => {
            this.model = gltf.scene;
            this.scene.add(this.model);
            this.fitCameraToEarth = () => {
              const fov = (this.camera.fov * Math.PI) / 180;
              this.camera.position.set(0, 0, 1.7); // Adjust if needed for better framing
              this.camera.lookAt(0, 0, 0);
              this.camera.updateProjectionMatrix();
            };
            this.handleResize();
            // Animation loop
            const animate = (time) => {
              if (this.model) {
                const deltaTime = (time - previousTime) / 1000;
                this.model.rotation.y += deltaTime * EARTH_ROTATION_SPEED;
                previousTime = time;
              }
              this.renderer.render(this.scene, this.camera);
              this._animationFrameId = requestAnimationFrame(animate);
            };
            this._animationFrameId = requestAnimationFrame(animate);
          });
          this.handleResize();
        }
      }
      customElements.define("earth-globe", EarthGlobe);
    </script>
  </body>
</html>
