<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        padding: 0;
        margin: 0;
        /* background: rgb(252, 249, 226); */
        background: black;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      .ascii {
        z-index: 2;
        position: relative;
        display: block;
      }
      #ascii-stars {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        margin: 0;
        padding: 0;
        z-index: 0;
        color: #fff;
        background: transparent;
        font-family: monospace;
        font-size: 12px;
        line-height: 12px;
        pointer-events: none;
        user-select: none;
        white-space: pre;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@v0.176.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.176.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <title>corytheboyd.com</title>
  </head>
  <body>
    <main>
      <div class="flex flex-col items-center justify-center w-full">
        <div></div>
        <div class="flex-1 bg-red-500">
          <earth-globe />
        </div>
      </div>
    </main>

    <script>
      // ASCII Starfield (fixed font size, always fills viewport)
      const starChars = [".", "*", "+"];
      let starCount = 120;
      let cols, rows;
      let stars = [];
      const asciiStars = document.getElementById("ascii-stars");
      const FONT_SIZE = 12; // px, must match CSS

      function updateGridSize() {
        cols = Math.floor(window.innerWidth / FONT_SIZE);
        rows = Math.floor(window.innerHeight / FONT_SIZE);
      }
      function randomStar() {
        return {
          x: Math.floor(Math.random() * cols),
          y: Math.floor(Math.random() * rows),
          char: starChars[Math.floor(Math.random() * starChars.length)],
          twinkle: Math.random() * 2 * Math.PI,
        };
      }
      function createStars() {
        stars = [];
        for (let i = 0; i < starCount; i++) {
          stars.push(randomStar());
        }
      }
      function drawStars(time) {
        let grid = Array.from({ length: rows }, () => Array(cols).fill(" "));
        for (let star of stars) {
          const tw = Math.abs(Math.sin(time / 500 + star.twinkle));
          if (tw > 0.5) {
            grid[star.y][star.x] = star.char;
          }
        }
        asciiStars.textContent = grid.map((row) => row.join("")).join("\n");
      }
      function animateStars(time = 0) {
        drawStars(time);
        requestAnimationFrame(animateStars);
      }
      function resizeStars() {
        updateGridSize();
        createStars();
      }

      // window.addEventListener("resize", resizeStars);
      // // Initial setup
      // updateGridSize();
      // createStars();
      // animateStars();
    </script>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      class EarthGlobe extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          const style = document.createElement("style");
          style.textContent = `:host { aspect-ratio: 1/1; width: min(100vw, 100vh); display: block; }`;
          this.shadowRoot.appendChild(style);
          this.container = document.createElement("div");
          this.container.style.width = "100%";
          this.container.style.height = "100%";
          this.container.style.position = "relative";
          this.shadowRoot.appendChild(this.container);
        }
        connectedCallback() {
          this.initThree();
          window.addEventListener("resize", this.handleResize);
        }
        disconnectedCallback() {
          window.removeEventListener("resize", this.handleResize);
          if (this.renderer) this.renderer.setAnimationLoop(null);
        }
        getSquareSize = () => {
          // Use the actual rendered size of the element
          return Math.min(this.offsetWidth, this.offsetHeight);
        };
        handleResize = () => {
          const size = this.getSquareSize();
          if (this.renderer) this.renderer.setSize(size, size);
          if (this.camera) {
            this.camera.aspect = 1;
            this.camera.updateProjectionMatrix();
          }
          if (this.fitCameraToEarth) this.fitCameraToEarth();
        };
        initThree() {
          const EARTH_ROTATION_SPEED = 0.3;
          let previousTime = 0;
          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(48.5, 1, 0.1, 2000);
          // Lighting
          const light = new THREE.DirectionalLight(0xffffff, 5.5);
          light.position.set(0, 0, 100);
          light.target.position.set(0, 0, 0);
          this.scene.add(light);
          this.scene.add(light.target);
          this.renderer = new THREE.WebGLRenderer({
            antialias: false,
            alpha: true,
          });
          this.renderer.setClearColor(0x2222ff, 1);
          this.container.innerHTML = "";
          this.container.appendChild(this.renderer.domElement);
          // Load model
          const loader = new GLTFLoader();
          loader.load("earth_low_poly.glb", (gltf) => {
            this.model = gltf.scene;
            this.scene.add(this.model);
            this.fitCameraToEarth = () => {
              const fov = (this.camera.fov * Math.PI) / 180;
              this.camera.position.set(0, 0, 1.7);
              this.camera.lookAt(0, 0, 0);
              this.camera.updateProjectionMatrix();
            };
            this.handleResize();
            // Animation loop
            this.renderer.setAnimationLoop((time) => {
              if (this.model) {
                const deltaTime = (time - previousTime) / 1000;
                this.model.rotation.y += deltaTime * EARTH_ROTATION_SPEED;
                previousTime = time;
              }
              this.renderer.render(this.scene, this.camera);
            });
          });
          this.handleResize();
        }
      }
      customElements.define("earth-globe", EarthGlobe);
    </script>
  </body>
</html>
