<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://fonts.googleapis.com/css2?family=VT323&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        padding: 0;
        margin: 0;
        background: #383b41;
        overflow: hidden;
      }
      #earth-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        /* width/height set dynamically */
      }
      canvas {
        display: block;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@v0.176.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.176.0/examples/jsm/"
        }
      }
    </script>
    <title>corytheboyd.com</title>
  </head>
  <body>
    <div id="earth-container"></div>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      let camera, scene, renderer, model, box, size;
      const container = document.getElementById("earth-container");

      init();

      function init() {
        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        scene = new THREE.Scene();

        // Add a light
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        // Load the model
        const loader = new GLTFLoader();
        loader.load(
          "earth.glb",
          function (gltf) {
            model = gltf.scene;
            scene.add(model);

            // Center the model
            box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            model.position.sub(center);

            // Get the size of the bounding box
            size = box.getSize(new THREE.Vector3());

            // Create camera (will be updated in resizeToFit)
            camera = new THREE.OrthographicCamera();
            camera.position.set(0, 0, 100);
            camera.lookAt(0, 0, 0);

            container.innerHTML = "";
            container.appendChild(renderer.domElement);

            resizeToFit();
            window.addEventListener("resize", resizeToFit);

            animate();
          },
          undefined,
          function (error) {
            console.error(error);
          }
        );
      }

      function resizeToFit() {
        if (!size) return;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const modelAspect = size.x / size.y;
        const windowAspect = windowWidth / windowHeight;

        // Scale to fit model in window, maintaining aspect ratio
        let scale;
        if (modelAspect > windowAspect) {
          // Fit to width
          scale = windowWidth / size.x;
        } else {
          // Fit to height
          scale = windowHeight / size.y;
        }
        const pixelWidth = Math.floor(size.x * scale);
        const pixelHeight = Math.floor(size.y * scale);

        renderer.setSize(pixelWidth, pixelHeight);
        container.style.width = pixelWidth + "px";
        container.style.height = pixelHeight + "px";

        // Update camera
        const frustumSize = Math.max(size.x, size.y);
        const aspect = pixelWidth / pixelHeight;
        camera.left = (-frustumSize * aspect) / 2;
        camera.right = (frustumSize * aspect) / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.near = 0.1;
        camera.far = 2000;
        camera.updateProjectionMatrix();
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
